//Tamaplanchi.ino
#include "Plant.h"
#include "LCD.h"
#include "MoistureSensor.h"
#include "Button.h"
#include "SDCard.h"

// Defining the pins
const uint8_t rs = 4, enable = 6, d0 = 10, d1 = 11, d2 = 12, d3 = 13;
#define MOISTURE_PIN A0
#define HAPPINESS_THRESHOLD 100
#define BUTTON_PIN 9
#define SDCARD_PIN 8

// Call constructors
Button button(BUTTON_PIN);
MoistureSensor moistureSensor(MOISTURE_PIN);
Plant plant(moistureSensor);
LCD lcd(rs, enable, d0, d1, d2, d3, button);
SDCard sdCard(SDCARD_PIN);

void setup() {
  lcd.begin(16, 2);  // set up the LCD's number of columns and rows: 
  // Create the custom character at location 0
  pinMode(MOISTURE_PIN, INPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  Serial.begin(9600);
  sdCard.begin();
  sdCard.writeFile("/test.txt", "Hello, world!");
}

void loop() {
  unsigned long currentTime = millis();
  if(button.checkPress(currentTime)){
    Serial.println("Button pressed");
  }
  lcd.updateDisplay(moistureSensor.getMoistureLevel(currentTime), plant.say(THANKS), plant.getLevel(), currentTime);
  // String content = sdCard.readFile("/test.txt"); // Read from file
  // Serial.println(content);
}

//Plant.h
#ifndef _PLANT_h
#define _PLANT_h
#include <Arduino.h>
#include "MoistureSensor.h"

enum MessageType {
  HELLO,
  GOODBYE,
  THANKS,
  LEVELUP,
  NUM_MESSAGES
};

class Plant {
public:
  Plant(MoistureSensor& moistureSensor);
  void updateHappiness(); 
  void levelUp();
  void checkInteraction(int gesture);
  int getLevel();
  int getHappiness();
  String getMessage();
  String say(MessageType type) const;
  unsigned long getTimeSinceWatering();
  void setTimeSinceWatering(unsigned long timeSinceWatering);
  void setMessage(String message);
  void updateLastWatering();
  int parseLastWatering();
  unsigned long getLastWatering();
  void checkWatering(unsigned long currentTime);

private:
  MoistureSensor _moistureSensor;
  int _level;
  int _happiness;
  int _happinessThreshold;
  unsigned long _lastWatering;
  unsigned long _lastInteraction;
  unsigned long _timeSinceWatering;
  unsigned long _lastWateringCheck;
  String _message;
  static const char* _messages[];
};

#endif

//Plant.cpp
#include "Plant.h"

const char* Plant::_messages[] = {
    "Hello!",
    "Goodbye!",
    "Thank you for watering me!",
    "I just leveled up to level %LEVEL%!"
    // Add more messages as needed
};

Plant::Plant(MoistureSensor& moistureSensor)
  : _moistureSensor(moistureSensor) {
  _level = 2;
  _happiness = 0;
  _lastInteraction = millis();
  _timeSinceWatering = 0;
  _lastWateringCheck = 0;
}

void Plant::updateHappiness(){
  
}
void Plant::levelUp() {
  _level++;
}

void Plant::checkInteraction(int gesture) {
  
}

int Plant::getLevel() {
  return _level;
}

int Plant::getHappiness() {
  return _happiness;
}

String Plant::say(MessageType type) const {
  if (type >= 0 && type < NUM_MESSAGES) {
        String message = _messages[type];
        // If variables needs to be changed in the message, it is done here
        message.replace("%LEVEL%", String(_level));
        return message;
    } else {
        return "Message not found.";
    }
}

void checkWatering(unsigned long currentTime){
  _currentTime = currentTime;
  if(_currentTime - _lastWateringCheck > 1000 || _currentTime < _lastWateringCheck){
    _lastWateringCheck = _currentTime;
    // check for watering
}

unsigned long Plant::getTimeSinceWatering() {
  return _timeSinceWatering;
}
void Plant::setTimeSinceWatering(unsigned long timeSinceWatering) {
  _timeSinceWatering = timeSinceWatering;
}
String Plant::getMessage() {
  return _message;
}
void Plant::setMessage(String message) {
  _message = message;
}

//LCD.h
#ifndef _LCD_h
#define _LCD_h

#include <Arduino.h>
#include <LiquidCrystal.h>
#include "Button.h"

class LCD : public LiquidCrystal {
public:
  LCD(uint8_t rs, uint8_t enable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3, Button& button);
  void displayCustomCharacters();
  void updateDisplay(int progress, String message, int level, unsigned long currentTime);
  void setButton(Button button);
  Button getButton();

private:
  void createCustomCharacters();
  void setProgressBar(int progress);
  void setLevel(int level);
  void setMessage(String message);
  int _maxProgress;
  unsigned long _currentTime;
  unsigned long _lastUpdate;
  unsigned long _lastScrollTime;
  int _scrollPosition;
  const int _lcdColumns = 16;
  const int _scrollSpeed = 250; 
  Button _button;
};

extern byte box[8];
extern byte verticalBorder[8];
extern byte endBorder[8];
extern byte startBorder[8];

#endif

//LCD.cpp
#include "LCD.h"
#include "Button.h"
LCD::LCD(uint8_t rs, uint8_t enable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3, Button& button)
  : LiquidCrystal(rs, enable, d0, d1, d2, d3), _button(button) {
  createCustomCharacters();
//   Set the max length of the progress bar
  _maxProgress = 6;
  _lastUpdate = 0;
  // Scrolling variables
  _lastScrollTime = 0;
  _scrollPosition = _lcdColumns;
  _currentTime = millis();
}

void LCD::updateDisplay(int progress, String message, int level, unsigned long currentTime){
  _currentTime = currentTime;
  if(_currentTime - _lastUpdate > 1000 || _currentTime < _lastUpdate){
    _lastUpdate = _currentTime;
    // TODO, change this clear to only clear the button row
    clear();
    setProgressBar(progress);
    setLevel(level);
    if(message.length() <= 15){
      setMessage(message);
    }
  }
  if(message.length() > 15){
    setMessage(message);
  }
}

void LCD::createCustomCharacters() {
  createChar(0, box);
  createChar(1, verticalBorder);
  createChar(2, endBorder);
  createChar(3, startBorder);
}

void LCD::displayCustomCharacters() {
  //TODO Implement custom display logic here
}

void LCD::setProgressBar(int progress) {
  setCursor(10, 1);
  if (progress < 0 or progress > _maxProgress) {
    return;
  } else if (progress == 0) {
      write((byte)3);
      for (int i = 0; i < _maxProgress - 2; i++) {
        write((byte)1);
    }
    write((byte)2);
  } else if (progress == _maxProgress) {
      for (int i = 0; i < progress; i++) {
        write((byte)0);
      }
  } else {
      for (int i = 0; i < progress; i++) {
        write((byte)0);
      }
    for (int i = 0; i < _maxProgress - progress - 1; i++) {
      write((byte)1);
    }
    write((byte)2);
  }
}
void LCD::setLevel(int level){
  setCursor(0,1);
  print("Lvl");
  setCursor(4, 1);
  print(level);
  //TODO Add a arrow up or down to indicate if lvl is increasing or decreasing
}
void LCD::setMessage(String message){
  if(message.length() < _lcdColumns){
    setCursor(0,0);
    print(message);
  } else{
      if (_currentTime - _lastScrollTime >= _scrollSpeed) { // scroll every 200ms
        _lastScrollTime = _currentTime;
        
        for (int i = 0; i < _lcdColumns; i++) {
          int charIndex = (_scrollPosition + i) % message.length();
          setCursor(i, 0);
          print(message.charAt(charIndex));
        }
        _scrollPosition++;
        if (_scrollPosition >= message.length()) {
          _scrollPosition = 0;
        }
      }
    }
}

void LCD::setButton(Button button){
  _button = button;
}

byte box[8] = {
  B11111,
  B11111,
  B11111,
  B11111,
  B11111,
  B11111,
  B11111,
  B11111
};

byte verticalBorder[8] = {
  0b11111,
  0b00000,
  0b00000,
  0b00000,
  0b00000,
  0b00000,
  0b00000,
  0b11111
};

byte endBorder[8] = {
  0b11111,
  0b00001,
  0b00001,
  0b00001,
  0b00001,
  0b00001,
  0b00001,
  0b11111
};

byte startBorder[8] = {
  0b11111,
  0b10000,
  0b10000,
  0b10000,
  0b10000,
  0b10000,
  0b10000,
  0b11111
};

//MoistureSensor.h
#ifndef MOISTURESENSOR_H
#define MOISTURESENSOR_H

#include <Arduino.h>
class MoistureSensor {
  private:
    int _sensorPin;
    int _moisture;
    unsigned long _lastUpdate;
    unsigned long _currentTime;
    int readMoisture();

  public:
    MoistureSensor(int pin);
    int getMoistureLevel(unsigned long currentTime);
};

#endif // MOISTURESENSOR_H

//MoistureSensor.cpp
#include "MoistureSensor.h"

MoistureSensor::MoistureSensor(int sensorPin)
  : _sensorPin(sensorPin){
    _moisture = 0;
    _lastUpdate = 0;
    _currentTime = 0;
  }

int MoistureSensor::readMoisture(){
  return analogRead(_sensorPin);
}

int MoistureSensor::getMoistureLevel(unsigned long currentTime){
  _currentTime = currentTime;

  if(_currentTime - _lastUpdate > 1000 || _currentTime < _lastUpdate){
    _moisture = readMoisture();
    _lastUpdate = _currentTime;
    Serial.println(_moisture);
    if(_moisture > 850){
      _moisture = 0;
    } else if (_moisture > 800){
        _moisture = 1;
    } else if (_moisture > 750){
        _moisture = 2;
    } else if (_moisture > 700){
        _moisture = 3;
    } else if (_moisture > 650){
        _moisture = 4;
    } else if (_moisture > 600){
        _moisture = 5;
    } else {
        _moisture = 6;
    }
  }
  return _moisture;
}

//SDCard.h
#ifndef SDCard_h
#define SDCard_h

#include <Arduino.h>
#include <SD.h>

class SDCard {
  public:
    SDCard(int csPin);
    void begin();
    void writeFile(const char* path, const char* message);
    String readFile(const char* path);
  private:
    int _csPin;
};

#endif

//SDCard.cpp
#include "SDCard.h"

SDCard::SDCard(int csPin) : _csPin(csPin) {}

void SDCard::begin() {
  if (!SD.begin(_csPin)) {
    Serial.println("Card initialization failed!");
    return;
  }
  Serial.println("SD Card Initialized");
}

void SDCard::writeFile(const char* path, const char* message) {
  File file = SD.open(path, FILE_WRITE);
  if (!file) {
    Serial.println("Failed to open file for writing");
    return;
  }
  if (file.print(message)) {
    Serial.println("File written");
  } else {
    Serial.println("Write failed");
  }
  file.close();
}

String SDCard::readFile(const char* path) {
  File file = SD.open(path);
  if (!file || file.isDirectory()) {
    Serial.println("Failed to open file for reading");
    return String();
  }
  String fileContent;
  while (file.available()) {
    fileContent += char(file.read());
  }
  file.close();
  return fileContent;
}

//Button.h
#ifndef BUTTON_H
#define BUTTON_H

#include <Arduino.h>
class Button{
  public:
    Button(int pin);
    void press();
    bool isPressed();
    bool checkPress(unsigned long currentTime);
  private:
    int _pin;
    bool _state;
    unsigned long _lastUpdate;
    unsigned long _currentTime;
};

#endif // BUTTON_H

//Button.cpp
#include "Button.h"
Button::Button(int pin)
  : _pin(pin) {
    _state = false;
    _lastUpdate = 0;
    _currentTime = 0;
  }
void Button::press(){
  _state = !_state;
}
bool Button::isPressed(){
  return _state;
}
bool Button::checkPress(unsigned long currentTime){
  // Logic, with millis(), to check whether button is pressed.
  _currentTime = currentTime;
  if(_currentTime - _lastUpdate > 200 || _currentTime < _lastUpdate){
    _lastUpdate = _currentTime;
    if(digitalRead(_pin) == LOW){
      press();
      return true;
    }
  }
  return false;
}

//needs to be implemented:
//Expressions.ino
#include <LedControl.h>

  const int DIN_PIN = 8;
  const int CS_PIN = 9;
  const int CLK_PIN = 7;
  int happiness = 0;
  int moisture = 0;
  
  const uint64_t IMAGES[] = {
    0x1020140202142010,
    0x0000340202340000,
    0x8050920202121000,
    0x0050320404325000,
    0x2038220404223820,
    0x5020530505532050,
    0x1f3f163d1d361f3f,
    0x4020130505132040
  };
  const int IMAGES_LEN = sizeof(IMAGES) / 8;
  
  
  LedControl display = LedControl(DIN_PIN, CLK_PIN, CS_PIN);
  
  
  void setup() {
    display.clearDisplay(0);
    display.shutdown(0, false);
    display.setIntensity(0, 10);
  }
  
  void displayImage(uint64_t image) {
    for (int i = 0; i < 8; i++) {
      byte row = (image >> i * 8) & 0xFF;
      for (int j = 0; j < 8; j++) {
        display.setLed(0, i, j, bitRead(row, j));
      }
    }
  }
  
  int i = 0;
  
  void loop() {
    // displayImage(IMAGES[i]);
    // if (++i >= IMAGES_LEN) {
    //   i = 0;
    // }
    happiness += 10;
    moisture += 10;
  
    if (happiness >= 100) {
      happiness = 0;
      moisture = 0;
    }
  
    defineMood(happiness, moisture);
  
    delay(100);
  }
  
  void defineMood(int happiness, int moisture) {
    if (happiness >= 70 && moisture >= 40 && moisture <= 60) {
      expression("happy");
    } else if (happiness == 50 && moisture >= 40 && moisture <= 60) {
      expression("default");
    } else if (happiness <= 30 && moisture >= 40 && moisture <= 60) {
      expression("bored");
    } else if (happiness <= 10 && moisture >= 70 && moisture <= 60) {
      expression("upset");
    } else if (moisture >= 90) {
      expression("cry");
    } else if (moisture == 0) {
      expression("dead");
    } else if (moisture == 100) {
      expression("drown");
    } else if (happiness <= 10) {
      expression("angry");
    } else {
      expression("default");
    }
  }
  
  void expression(String expression) {
    if (expression == "happy") {
      displayImage(IMAGES[0]);
    } else if (expression == "default") {
      displayImage(IMAGES[1]);
    } else if (expression == "bored") {
      displayImage(IMAGES[2]);
    } else if (expression == "upset") {
      displayImage(IMAGES[3]);
    } else if (expression == "cry") {
      displayImage(IMAGES[4]);
    } else if (expression == "dead") {
      displayImage(IMAGES[5]);
    } else if (expression == "drown") {
      displayImage(IMAGES[6]);
    } else if (expression == "angry") {
      displayImage(IMAGES[7]);
    }
  }

  //Distance.ino
  int echoPin = 10;  // attach pin D2 Arduino to pin Echo of HC-SR04
int trigPin = 6;   //attach pin D3 Arduino to pin Trig of HC-SR04
long duration;     // variable for the duration of sound wave travel
int distance;      // variable for the distance measurement

int previousDistance = 0;
unsigned long previousTime = 0;
int closeDetections = 0;


void setup() {
  pinMode(trigPin, OUTPUT);    // Sets the trigPin as an OUTPUT
  pinMode(echoPin, INPUT);     // Sets the echoPin as an INPUT
  digitalWrite(trigPin, LOW);  //MAKE SURE PIN START LOW
  Serial.begin(9600);          // Serial Communication is starting with 9600 of baudrate speed
}
void loop() {

  unsigned long currentTime = millis();
  // Sets the trigPin HIGH (ACTIVE) for 10 microseconds

  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  // Reads the echoPin, returns the sound wave travel time in microseconds
  duration = pulseIn(echoPin, HIGH);  //length of pulse in microseconds (1uS = 0.000001s)
  distance = duration * 0.034 / 2;    // DISTANCE = Speed of sound wave (343m/s) divided by 2 (out and back)
  // Displays the distance on the Serial Monitor
  Serial.print("Distance: ");
  Serial.print(distance);
  Serial.println(" cm");
 

  int currentDistance = distance;

  if (currentDistance <= 100) {
    // happiness + 10 because detect that owner is near
  }

  Serial.println("time");
  Serial.println(currentTime);
  Serial.println(previousTime);
  if (currentTime - previousTime >= 2000) {
    // Reset previous values if more than 3 seconds have passed
    previousDistance = currentDistance;
    previousTime = currentTime;
    closeDetections = 0;
    // happiness -0.01 no interaction 
  } else {
    // Check if current distance is close to previous distance
    previousTime = currentTime;
    int distanceDifference = abs(currentDistance - previousDistance);
    Serial.println(distanceDifference);
    if (distanceDifference > 200) {  // Adjust this threshold as needed
      closeDetections++;
      previousDistance = currentDistance;
      Serial.println("closeDetections: ");
      Serial.println(closeDetections);
      if (closeDetections == 4) {
        // Object has been close two times in the past 3 seconds, take action here
        Serial.println("Wave detected!");
        // happiness +10 because interact with owner
        delay(5000);
        closeDetections = 0;
      }
    }
  }

  previousDistance = currentDistance;
}